
<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <title>T-Rex Clone — com sua imagem</title>
  <style>
    html,body { height:100%; margin:0; background:#f7f7f7; display:flex; align-items:center; justify-content:center; font-family:Arial, Helvetica, sans-serif; }
    .container { width:900px; max-width:96vw; }
    canvas { background:#fff; display:block; width:100%; height:200px; border:1px solid #ddd; box-shadow:0 6px 18px rgba(0,0,0,0.08); }
    .info { margin-top:8px; display:flex; justify-content:space-between; align-items:center; gap:8px; }
    .hint { color:#555; font-size:14px; }
    button { padding:8px 12px; border-radius:6px; border:1px solid #ccc; background:#f0f0f0; cursor:pointer; }
  </style>
</head>
<body>
  <div class="container">
    <canvas id="game" width="900" height="200"></canvas>
    <div class="info">
      <div class="hint">Espaço / Clique / ↑ para pular. Evite os obstáculos. Pressione R para reiniciar.</div>
      <div><strong>Pontos: <span id="score">0</span></strong></div>
    </div>
  </div>

<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  const W = canvas.width;
  const H = canvas.height;

  // Image provided by the user (file shipped with this HTML).
  const DINO_SRC = 'bfe32ec5-578e-458d-84da-1cfe1edd47eb.webp';

  // Game state
  let dino = { x: 50, y: 0, w: 80, h: 80, vy:0, grounded: false };
  let gravity = 0.8;
  let jumpStrength = -14;
  let obstacles = [];
  let spawnTimer = 0;
  let speed = 6;
  let running = true;
  let score = 0;
  let highScore = 0;

  // Load image and scale proportionally after load
  const img = new Image();
  img.src = DINO_SRC;
  img.onload = () => {
    // keep width = 80 (or less if image is small), compute height proportionally
    const targetW = 80;
    const ratio = img.naturalHeight / img.naturalWidth;
    dino.w = targetW;
    dino.h = Math.round(targetW * ratio);
    dino.y = groundY() - dino.h;
    draw(); // initial draw
  };

  function groundY(){ return H - 30; }

  function reset(){
    dino.x = 50;
    dino.vy = 0;
    dino.y = groundY() - dino.h;
    obstacles = [];
    spawnTimer = 0;
    speed = 6;
    running = true;
    score = 0;
    document.getElementById('score').textContent = score;
    loop();
  }

  function spawnObstacle(){
    // obstacle will be a rectangle or a small block; vary size
    const h = 20 + Math.random()*40;
    const w = 12 + Math.random()*30;
    obstacles.push({ x: W + 10, y: groundY() - h, w, h });
  }

  function update(){
    if(!running) return;

    // Dino physics
    dino.vy += gravity;
    dino.y += dino.vy;
    if(dino.y + dino.h >= groundY()){
      dino.y = groundY() - dino.h;
      dino.vy = 0;
      dino.grounded = true;
    } else {
      dino.grounded = false;
    }

    // Obstacles
    spawnTimer--;
    if(spawnTimer <= 0){
      spawnObstacle();
      spawnTimer = 60 + Math.floor(Math.random()*80) - Math.floor(score/100);
      if(spawnTimer < 40) spawnTimer = 40;
    }

    for(let i = obstacles.length-1; i >=0; i--){
      obstacles[i].x -= speed;
      if(obstacles[i].x + obstacles[i].w < -50) obstacles.splice(i,1);
      else {
        // collision check
        if(collideRect(dino.x, dino.y, dino.w, dino.h, obstacles[i].x, obstacles[i].y, obstacles[i].w, obstacles[i].h)){
          running = false;
        }
      }
    }

    // Speed & score
    score += 1;
    if(score % 100 === 0) speed += 0.25;
    document.getElementById('score').textContent = score;
  }

  function collideRect(x1,y1,w1,h1,x2,y2,w2,h2){
    return !(x1 + w1 < x2 || x1 > x2 + w2 || y1 + h1 < y2 || y1 > y2 + h2);
  }

  function draw(){
    // clear
    ctx.clearRect(0,0,W,H);

    // ground
    ctx.fillStyle = '#efefef';
    ctx.fillRect(0, groundY(), W, H-groundY());

    // draw dino (image) - if not loaded yet, draw a placeholder
    if(img.complete && img.naturalWidth){
      ctx.drawImage(img, dino.x, dino.y, dino.w, dino.h);
    } else {
      ctx.fillStyle = '#333';
      ctx.fillRect(dino.x, dino.y, dino.w, dino.h);
    }

    // obstacles
    ctx.fillStyle = '#222';
    obstacles.forEach(o => {
      ctx.fillRect(o.x, o.y, o.w, o.h);
    });

    // small ground line
    ctx.strokeStyle = '#ddd';
    ctx.beginPath();
    ctx.moveTo(0, groundY());
    ctx.lineTo(W, groundY());
    ctx.stroke();

    // game over text
    if(!running){
      ctx.fillStyle = 'rgba(0,0,0,0.6)';
      ctx.fillRect(W/2 - 160, H/2 - 40, 320, 80);
      ctx.fillStyle = '#fff';
      ctx.font = '18px Arial';
      ctx.textAlign = 'center';
      ctx.fillText('Game Over — pressione R para reiniciar', W/2, H/2 + 6);
    }
  }

  function loop(){
    update();
    draw();
    if(running) requestAnimationFrame(loop);
  }

  // Input
  function tryJump(){
    if(!running) return;
    if(dino.grounded){
      dino.vy = jumpStrength;
      dino.grounded = false;
    }
  }

  window.addEventListener('keydown', (e) => {
    if(e.code === 'Space' || e.code === 'ArrowUp') {
      e.preventDefault();
      tryJump();
    } else if(e.key === 'r' || e.key === 'R'){
      reset();
    }
  });

  // Click to jump
  canvas.addEventListener('mousedown', (e) => {
    tryJump();
  });

  // Touch support
  canvas.addEventListener('touchstart', (e) => {
    e.preventDefault();
    tryJump();
  }, {passive:false});

  // start
  dino.y = groundY() - dino.h;
  loop();

  // Expose some controls to console for experimentation
  window.__trex = { reset, obstacles, dino };
})();
</script>
</body>
</html>
